<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Rule Stack - Mejorado</title>
<style>
body {
    margin: 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: 'Arial', sans-serif;
}
canvas {
    background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
    border: 4px solid #0f3460;
    box-shadow: 0 0 40px rgba(0,0,0,0.7);
}
</style>
</head>
<body>
<canvas id="game" width="400" height="600"></canvas>

<script>
// ==========================================
// CONFIGURACIÓN Y CONSTANTES
// ==========================================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const WIDTH = canvas.width;
const HEIGHT = canvas.height;

// Constantes de bloques
const BLOCK_HEIGHT = 35;
const INITIAL_BLOCK_WIDTH = 150;
const INITIAL_SPEED = 2.5;
const SPEED_INCREMENT = 0.08;
const MAX_SPEED = 7;

// Tolerancia para alineación perfecta (en píxeles)
const PERFECT_THRESHOLD = 5;

// Colores
const COLORS = [
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', 
    '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'
];

// ==========================================
// CLASE PARTICLE - Partículas decorativas
// ==========================================
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = (Math.random() - 0.5) * 6 - 2;
        this.life = 1;
        this.decay = 0.02;
        this.size = Math.random() * 4 + 2;
        this.color = color;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; // Gravedad
        this.life -= this.decay;
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    isDead() {
        return this.life <= 0;
    }
}

// ==========================================
// CLASE BLOCK - Bloque individual
// ==========================================
class Block {
    constructor(x, y, width, height, color, isMoving = false) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.color = color;
        this.isMoving = isMoving;
        this.direction = 1;
        this.velocity = 0;
        this.falling = false;
        this.rotation = 0;
        this.opacity = 1;
    }

    move(speed) {
        if (!this.isMoving || this.falling) return;

        this.x += this.direction * speed;

        // Rebote suave en los bordes
        if (this.x + this.width >= WIDTH) {
            this.x = WIDTH - this.width;
            this.direction = -1;
        } else if (this.x <= 0) {
            this.x = 0;
            this.direction = 1;
        }
    }

    fall() {
        this.falling = true;
        this.velocity = 0;
    }

    updateFalling() {
        if (!this.falling) return;

        this.velocity += 0.5; // Gravedad
        this.y += this.velocity;
        this.rotation += 0.1;
        this.opacity -= 0.015;
    }

    draw() {
        ctx.save();
        
        // Aplicar rotación si está cayendo
        if (this.falling) {
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.rotate(this.rotation);
            ctx.globalAlpha = this.opacity;
            
            // Sombra
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            // Bloque
            const gradient = ctx.createLinearGradient(
                -this.width / 2, 0, 
                this.width / 2, 0
            );
            gradient.addColorStop(0, this.lightenColor(this.color, 20));
            gradient.addColorStop(0.5, this.color);
            gradient.addColorStop(1, this.darkenColor(this.color, 20));
            
            ctx.fillStyle = gradient;
            ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
            
            // Borde
            ctx.strokeStyle = this.darkenColor(this.color, 40);
            ctx.lineWidth = 2;
            ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
        } else {
            // Sombra
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            // Gradiente para el bloque
            const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y);
            gradient.addColorStop(0, this.lightenColor(this.color, 20));
            gradient.addColorStop(0.5, this.color);
            gradient.addColorStop(1, this.darkenColor(this.color, 20));
            
            ctx.fillStyle = gradient;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            
            // Borde brillante
            ctx.strokeStyle = this.lightenColor(this.color, 30);
            ctx.lineWidth = 2;
            ctx.strokeRect(this.x, this.y, this.width, this.height);
            
            // Borde oscuro
            ctx.strokeStyle = this.darkenColor(this.color, 40);
            ctx.lineWidth = 2;
            ctx.strokeRect(this.x + 2, this.y + 2, this.width - 4, this.height - 4);
            
            // Brillo superior
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, this.height / 3);
        }
        
        ctx.restore();
    }

    lightenColor(color, percent) {
        const num = parseInt(color.replace("#",""), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.min(255, (num >> 16) + amt);
        const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
        const B = Math.min(255, (num & 0x0000FF) + amt);
        return `#${(0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1)}`;
    }

    darkenColor(color, percent) {
        const num = parseInt(color.replace("#",""), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.max(0, (num >> 16) - amt);
        const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
        const B = Math.max(0, (num & 0x0000FF) - amt);
        return `#${(0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1)}`;
    }

    isOffScreen() {
        return this.y > HEIGHT + 100;
    }
}

// ==========================================
// CLASE GAME - Lógica principal del juego
// ==========================================
class Game {
    constructor() {
        this.stack = [];
        this.currentBlock = null;
        this.particles = [];
        this.speed = INITIAL_SPEED;
        this.score = 0;
        this.highScore = parseInt(localStorage.getItem('stackHighScore')) || 0;
        this.gameOver = false;
        this.perfectMessage = null;
        this.perfectTimer = 0;
        this.comboCount = 0;
        this.flashEffect = 0;
        
        this.setupControls();
        this.reset();
    }

    setupControls() {
        document.addEventListener("keydown", e => {
            if (e.code === "Space") {
                e.preventDefault();
                this.placeBlock();
            }
        });
        
        canvas.addEventListener("click", () => this.placeBlock());
    }

    reset() {
        this.stack = [];
        this.particles = [];
        this.currentBlock = new Block(
            0, 
            HEIGHT - BLOCK_HEIGHT - 10, 
            INITIAL_BLOCK_WIDTH, 
            BLOCK_HEIGHT, 
            COLORS[0], 
            true
        );
        this.speed = INITIAL_SPEED;
        this.score = 0;
        this.gameOver = false;
        this.perfectMessage = null;
        this.perfectTimer = 0;
        this.comboCount = 0;
        this.flashEffect = 0;
    }

    placeBlock() {
        if (this.gameOver) {
            this.reset();
            return;
        }

        if (!this.currentBlock || !this.currentBlock.isMoving) return;

        // Primer bloque siempre se coloca
        if (this.stack.length === 0) {
            this.stack.push(this.currentBlock);
            this.currentBlock.isMoving = false;
            this.score++;
            this.createParticles(this.currentBlock);
            this.spawnNewBlock();
            return;
        }

        const previousBlock = this.stack[this.stack.length - 1];
        
        // Calcular superposición
        const overlapStart = Math.max(previousBlock.x, this.currentBlock.x);
        const overlapEnd = Math.min(
            previousBlock.x + previousBlock.width, 
            this.currentBlock.x + this.currentBlock.width
        );
        const overlapWidth = overlapEnd - overlapStart;

        // Sin superposición = Game Over
        if (overlapWidth <= 0) {
            this.currentBlock.fall();
            this.gameOver = true;
            this.flashEffect = 1;
            
            if (this.score > this.highScore) {
                this.highScore = this.score;
                localStorage.setItem('stackHighScore', this.highScore);
            }
            return;
        }

        // Ajustar el bloque actual a la superposición
        this.currentBlock.x = overlapStart;
        this.currentBlock.width = overlapWidth;
        this.currentBlock.isMoving = false;

        // Detectar alineación perfecta
        const alignmentDiff = Math.abs(previousBlock.x - this.currentBlock.x);
        const widthDiff = Math.abs(previousBlock.width - this.currentBlock.width);
        
        if (alignmentDiff <= PERFECT_THRESHOLD && widthDiff <= PERFECT_THRESHOLD) {
            this.perfectMessage = "¡PERFECTO!";
            this.perfectTimer = 60;
            this.comboCount++;
            this.score += 2; // Bonus por perfecto
            this.createPerfectParticles(this.currentBlock);
        } else {
            this.perfectMessage = null;
            this.comboCount = 0;
            this.score++;
        }

        this.stack.push(this.currentBlock);
        this.createParticles(this.currentBlock);
        
        // Aumentar velocidad progresivamente
        this.speed = Math.min(INITIAL_SPEED + (this.score * SPEED_INCREMENT), MAX_SPEED);
        
        this.spawnNewBlock();
    }

    spawnNewBlock() {
        if (this.stack.length === 0) return;

        const previousBlock = this.stack[this.stack.length - 1];
        
        // Calcular la posición Y del nuevo bloque (justo encima del anterior)
        let newY = previousBlock.y - BLOCK_HEIGHT;
        
        // Si la torre llega muy arriba, desplazar TODA la torre hacia abajo
        const MIN_Y_THRESHOLD = 100;
        if (newY < MIN_Y_THRESHOLD) {
            const shiftAmount = BLOCK_HEIGHT;
            
            // Desplazar todos los bloques de la torre hacia abajo
            this.stack.forEach(block => {
                block.y += shiftAmount;
            });
            
            // Recalcular la posición del nuevo bloque después del desplazamiento
            newY = this.stack[this.stack.length - 1].y - BLOCK_HEIGHT;
        }

        const colorIndex = this.stack.length % COLORS.length;
        this.currentBlock = new Block(
            0,
            newY,
            previousBlock.width,
            BLOCK_HEIGHT,
            COLORS[colorIndex],
            true
        );
    }

    createParticles(block) {
        const particleCount = 15;
        for (let i = 0; i < particleCount; i++) {
            const x = block.x + Math.random() * block.width;
            const y = block.y + block.height / 2;
            this.particles.push(new Particle(x, y, block.color));
        }
    }

    createPerfectParticles(block) {
        const particleCount = 30;
        for (let i = 0; i < particleCount; i++) {
            const x = block.x + Math.random() * block.width;
            const y = block.y + block.height / 2;
            this.particles.push(new Particle(x, y, '#FFD700'));
        }
    }

    update() {
        if (this.gameOver) {
            // Actualizar bloques que caen
            this.stack.forEach(block => {
                if (block.falling) {
                    block.updateFalling();
                }
            });
            
            if (this.currentBlock) {
                this.currentBlock.updateFalling();
            }
            
            this.stack = this.stack.filter(block => !block.isOffScreen());
            
            if (this.flashEffect > 0) {
                this.flashEffect -= 0.05;
            }
            
            // Actualizar partículas
            this.particles.forEach(particle => particle.update());
            this.particles = this.particles.filter(p => !p.isDead());
            
            return;
        }

        // Mover bloque actual
        if (this.currentBlock && this.currentBlock.isMoving) {
            this.currentBlock.move(this.speed);
        }

        // Actualizar temporizador de mensaje perfecto
        if (this.perfectTimer > 0) {
            this.perfectTimer--;
        }

        // Actualizar partículas
        this.particles.forEach(particle => particle.update());
        this.particles = this.particles.filter(p => !p.isDead());
    }

    drawBackground() {
        // Fondo degradado
        const gradient = ctx.createLinearGradient(0, 0, 0, HEIGHT);
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(1, '#16213e');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // Patrón de puntos decorativos
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        for (let y = 0; y < HEIGHT; y += 30) {
            for (let x = 0; x < WIDTH; x += 30) {
                ctx.beginPath();
                ctx.arc(x, y, 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    drawUI() {
        // Puntuación actual
        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 4;
        ctx.font = 'bold 36px Arial';
        ctx.textAlign = 'center';
        ctx.strokeText(this.score, WIDTH / 2, 50);
        ctx.fillText(this.score, WIDTH / 2, 50);

        // High Score
        ctx.font = '16px Arial';
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.fillText(`Mejor: ${this.highScore}`, WIDTH / 2, 75);

        // Velocidad actual
        ctx.fillText(`Velocidad: ${this.speed.toFixed(1)}x`, WIDTH / 2, 95);

        // Mensaje de perfecto
        if (this.perfectTimer > 0) {
            ctx.save();
            const scale = 1 + (Math.sin(this.perfectTimer * 0.2) * 0.1);
            ctx.translate(WIDTH / 2, 150);
            ctx.scale(scale, scale);
            
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#FF6B00';
            ctx.lineWidth = 3;
            ctx.font = 'bold 32px Arial';
            ctx.strokeText(this.perfectMessage, 0, 0);
            ctx.fillText(this.perfectMessage, 0, 0);
            
            if (this.comboCount > 1) {
                ctx.font = '20px Arial';
                ctx.fillText(`Combo x${this.comboCount}`, 0, 30);
            }
            
            ctx.restore();
        }

        // Instrucciones al inicio
        if (this.score === 0 && this.stack.length === 0) {
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.font = '20px Arial';
            ctx.fillText('Pulsa ESPACIO o CLICK', WIDTH / 2, HEIGHT / 2);
            ctx.fillText('para colocar bloques', WIDTH / 2, HEIGHT / 2 + 30);
        }

        // Game Over
        if (this.gameOver) {
            // Efecto de flash
            if (this.flashEffect > 0) {
                ctx.fillStyle = `rgba(255, 0, 0, ${this.flashEffect * 0.3})`;
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
            }

            // Panel de Game Over
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(50, HEIGHT / 2 - 100, WIDTH - 100, 200);

            ctx.fillStyle = '#FF6B6B';
            ctx.font = 'bold 40px Arial';
            ctx.fillText('GAME OVER', WIDTH / 2, HEIGHT / 2 - 40);

            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.fillText(`Puntuación: ${this.score}`, WIDTH / 2, HEIGHT / 2 + 10);
            ctx.fillText(`Mejor: ${this.highScore}`, WIDTH / 2, HEIGHT / 2 + 45);

            ctx.font = '18px Arial';
            ctx.fillStyle = '#4ECDC4';
            ctx.fillText('ESPACIO o CLICK para reiniciar', WIDTH / 2, HEIGHT / 2 + 80);
        }
    }

    draw() {
        // Limpiar canvas
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        // Dibujar fondo
        this.drawBackground();

        // Dibujar bloques apilados
        this.stack.forEach(block => block.draw());

        // Dibujar bloque actual
        if (this.currentBlock) {
            this.currentBlock.draw();
        }

        // Dibujar partículas
        this.particles.forEach(particle => particle.draw());

        // Dibujar UI
        this.drawUI();
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

// ==========================================
// INICIAR JUEGO
// ==========================================
const game = new Game();
game.loop();

</script>
</body>
</html>

