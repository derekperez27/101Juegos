<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Inverted Runner ‚Äì 1 Lane</title>
<style>
body{
    margin:0;
    background:#111;
    color:white;
    font-family:Arial;
    text-align:center;
}
canvas{
    background:#000;
    display:block;
    margin:20px auto;
    border:2px solid white;
}
#records {
    margin: 20px auto;
    max-width: 400px;
}
#records h2 {
    color: #00ff00;
}
#recordsList {
    background: #222;
    border: 2px solid #444;
    border-radius: 8px;
    padding: 15px;
    max-height: 300px;
    overflow-y: auto;
}
.record-item {
    display: flex;
    justify-content: space-between;
    padding: 8px;
    margin: 5px 0;
    background: #333;
    border-radius: 5px;
    border-left: 3px solid #00ff00;
}
.record-rank {
    font-weight: bold;
    color: #00ff00;
    margin-right: 10px;
}
.record-time {
    color: #4CAF50;
    font-weight: bold;
}
.no-records {
    color: #888;
    font-style: italic;
    padding: 20px;
}
button {
    padding: 8px 15px;
    font-size: 16px;
    margin: 5px;
    cursor: pointer;
}
</style>
</head>
<body>

<h1>üîÑ Inverted Runner</h1>
<p>Tiempo: <span id="time">0</span>s | Velocidad: <span id="speedDisplay">5.0</span></p>
<p id="state" style="font-size:20px; color:#00ff00;">‚ñ∂ AVANZANDO</p>
<p style="color:#888; font-size:12px;">W: Saltar | S: Agacharse | R: Reiniciar</p>

<canvas id="c" width="600" height="200"></canvas>

<div id="records">
    <h2>üèÜ R√©cords</h2>
    <div id="recordsList"></div>
    <button onclick="clearRecords()" style="background: #d32f2f; color: white;">Borrar R√©cords</button>
</div>

<script>
const c = document.getElementById("c");
const ctx = c.getContext("2d");
const timeSpan = document.getElementById("time");
const speedDisplay = document.getElementById("speedDisplay");
const stateText = document.getElementById("state");

let time = 0;
let speed = 5;
let direction = 1; // 1 adelante, -1 atr√°s
let running = true;
let forwardTime = 10; // Segundos avanzando
let backwardTime = 4; // Segundos retrocediendo
let phaseTime = 0; // Tiempo en la fase actual

/* ===== R√âCORDS ===== */
function loadRecords() {
    const records = localStorage.getItem('invertedRunnerRecords');
    return records ? JSON.parse(records) : [];
}

function saveRecord(time) {
    const records = loadRecords();
    records.push({
        time: time,
        date: new Date().toLocaleDateString()
    });
    // Ordenar por tiempo (mayor a menor)
    records.sort((a, b) => b.time - a.time);
    // Guardar solo los mejores 10
    const top10 = records.slice(0, 10);
    localStorage.setItem('invertedRunnerRecords', JSON.stringify(top10));
    displayRecords();
}

function displayRecords() {
    const records = loadRecords();
    const recordsList = document.getElementById('recordsList');
    
    if (records.length === 0) {
        recordsList.innerHTML = '<div class="no-records">No hay r√©cords a√∫n. ¬°S√© el primero!</div>';
        return;
    }

    recordsList.innerHTML = records.map((record, index) => {
        let medal = '';
        if (index === 0) medal = 'ü•á';
        else if (index === 1) medal = 'ü•à';
        else if (index === 2) medal = 'ü•â';
        
        return `
            <div class="record-item">
                <span class="record-rank">${medal} #${index + 1}</span>
                <span class="record-time">${record.time}s</span>
                <span style="color: #666; font-size: 12px;">${record.date}</span>
            </div>
        `;
    }).join('');
}

function clearRecords() {
    if (confirm('¬øEst√°s seguro de que quieres borrar todos los r√©cords?')) {
        localStorage.removeItem('invertedRunnerRecords');
        displayRecords();
    }
}

// Mostrar r√©cords al cargar la p√°gina
displayRecords();

/* ===== PLAYER ===== */
const player = {
    x: 80,
    y: 130,
    w: 30,
    h: 40,
    vy: 0,
    jumping: false,
    crouching: false,
    groundY: 130
};

/* ===== OBSTACLES ===== */
let obstacles = [];

function spawnObstacle(){
    const type = Math.floor(Math.random()*2); // 0 alto, 1 bajo
    obstacles.push({
        x: 600, // Siempre aparecen desde la derecha
        y: type === 0 ? 105 : 140,
        w: 30,
        h: type === 0 ? 25 : 30,
        type
    });
}

/* ===== INPUT ===== */
document.addEventListener("keydown",e=>{
    if(!running) {
        if(e.key === "r" || e.key === "R") restart();
        return;
    }

    if((e.key==="w" || e.key==="W") && !player.jumping){
        player.jumping = true;
        player.vy = -12;
    }
    if(e.key==="s" || e.key==="S"){
        player.crouching = true;
        setTimeout(()=>player.crouching=false,350);
    }
});

/* ===== UPDATE ===== */
function update(){
    if(!running) return;

    // salto
    if(player.jumping){
        player.y += player.vy;
        player.vy += 0.8;
        if(player.y >= player.groundY){
            player.y = player.groundY;
            player.jumping = false;
            player.vy = 0;
        }
    }

    // mover obst√°culos horizontalmente
    obstacles.forEach(o=>{
        o.x -= speed * direction;
    });

    // colisiones
    obstacles.forEach(o=>{
        const playerW = player.crouching ? player.w : player.w;
        const playerH = player.crouching ? 20 : player.h;
        const playerY = player.crouching ? player.y + 20 : player.y;
        
        if(o.x < player.x + playerW &&
           o.x + o.w > player.x &&
           o.y < playerY + playerH &&
           o.y + o.h > playerY){
            die();
        }
    });
    
    // Limpiar obst√°culos solo cuando salen completamente por la derecha
    // Los que salen por la izquierda se mantienen para volver cuando retrocede
    obstacles = obstacles.filter(o => o.x < 700);
}

/* ===== DRAW ===== */
function draw(){
    ctx.clearRect(0,0,600,200);

    // Fondo seg√∫n direcci√≥n
    ctx.fillStyle = direction === 1 ? "rgba(0,50,0,0.1)" : "rgba(50,0,0,0.1)";
    ctx.fillRect(0,0,600,200);

    // Suelo
    ctx.strokeStyle="#444";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, 170);
    ctx.lineTo(600, 170);
    ctx.stroke();
    
    // L√≠neas decorativas del suelo (animadas seg√∫n direcci√≥n)
    ctx.strokeStyle="#333";
    const offset = direction === 1 ? (Date.now() / 50) % 50 : -(Date.now() / 50) % 50;
    for(let i = 0; i < 15; i++){
        const x = (i * 50 + offset) % 600;
        ctx.beginPath();
        ctx.moveTo(x, 175);
        ctx.lineTo(x + 20, 175);
        ctx.stroke();
    }
    
    // L√≠neas del carril central
    ctx.strokeStyle="#222";
    ctx.setLineDash([10, 10]);
    ctx.beginPath();
    ctx.moveTo(0, 100);
    ctx.lineTo(600, 100);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Flecha indicadora de direcci√≥n
    ctx.fillStyle = direction === 1 ? "#00ff00" : "#ff4444";
    ctx.font = "30px Arial";
    ctx.fillText(direction === 1 ? "‚ñ∂‚ñ∂‚ñ∂" : "‚óÄ‚óÄ‚óÄ", 260, 30);

    // jugador
    ctx.fillStyle="cyan";
    const h = player.crouching ? 20 : player.h;
    const y = player.crouching ? player.y + 20 : player.y;
    ctx.fillRect(player.x, y, player.w, h);

    // obst√°culos
    obstacles.forEach(o=>{
        ctx.fillStyle = o.type===0 ? "red" : "blue";
        ctx.fillRect(o.x, o.y, o.w, o.h);
    });
}

/* ===== LOOP ===== */
function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
}

/* ===== TIEMPO / INVERSI√ìN / DIFICULTAD ===== */
let timeTimer = setInterval(()=>{
    if(!running) return;

    time++;
    phaseTime++;
    timeSpan.textContent = time;

    // Cambiar de direcci√≥n seg√∫n fase
    if(direction === 1 && phaseTime >= forwardTime){
        // Cambiar a retroceder
        direction = -1;
        phaseTime = 0;
        stateText.textContent = "‚óÄ RETROCEDIENDO";
        stateText.style.color = "#ff4444";
    } else if(direction === -1 && phaseTime >= backwardTime){
        // Cambiar a avanzar
        direction = 1;
        phaseTime = 0;
        stateText.textContent = "‚ñ∂ AVANZANDO";
        stateText.style.color = "#00ff00";
    }

    // Aumentar velocidad cada 3 segundos y m√°s agresivamente
    if(time % 3 === 0) {
        speed += 0.6; // Incremento mayor
        speedDisplay.textContent = speed.toFixed(1);
    }
    
    // Reducir tiempo de retroceso progresivamente
    if(time === 40 && backwardTime > 3) backwardTime = 3;
    if(time === 80 && backwardTime > 2) backwardTime = 2;
    
    // Reducir tiempo de avance para mayor dificultad
    if(time === 60 && forwardTime > 8) forwardTime = 8;
    if(time === 120 && forwardTime > 6) forwardTime = 6;

},1000);

let spawnTimer = setInterval(()=>{
    if(running && direction === 1){
        spawnObstacle();
    }
},600); // Spawn m√°s frecuente

/* ===== GAME OVER ===== */
function die(){
    running = false;
    
    // Guardar r√©cord
    saveRecord(time);
    
    const records = loadRecords();
    const isTopRecord = records.length > 0 && records[0].time === time;
    
    if(isTopRecord){
        stateText.innerHTML = "üèÜ ¬°NUEVO R√âCORD! üíÄ GAME OVER<br><span style='font-size:14px;'>Presiona R para reiniciar</span>";
        stateText.style.color = "#ffd700";
    } else {
        stateText.innerHTML = "üíÄ GAME OVER<br><span style='font-size:14px;'>Presiona R para reiniciar</span>";
        stateText.style.color = "#ff4444";
    }
    
    clearInterval(timeTimer);
    clearInterval(spawnTimer);
}

/* ===== REINICIO ===== */
function restart(){
    // Resetear variables
    time = 0;
    phaseTime = 0;
    speed = 5;
    direction = 1;
    forwardTime = 10;
    backwardTime = 4;
    running = true;
    obstacles = [];
    
    player.x = 80;
    player.y = 130;
    player.groundY = 130;
    player.vy = 0;
    player.jumping = false;
    player.crouching = false;
    
    timeSpan.textContent = 0;
    speedDisplay.textContent = "5.0";
    stateText.textContent = "‚ñ∂ AVANZANDO";
    stateText.style.color = "#00ff00";
    
    // Reiniciar timers
    clearInterval(timeTimer);
    clearInterval(spawnTimer);
    
    timeTimer = setInterval(()=>{
        if(!running) return;
        time++;
        phaseTime++;
        timeSpan.textContent = time;
        
        if(direction === 1 && phaseTime >= forwardTime){
            direction = -1;
            phaseTime = 0;
            stateText.textContent = "‚óÄ RETROCEDIENDO";
            stateText.style.color = "#ff4444";
        } else if(direction === -1 && phaseTime >= backwardTime){
            direction = 1;
            phaseTime = 0;
            stateText.textContent = "‚ñ∂ AVANZANDO";
            stateText.style.color = "#00ff00";
        }
        
        if(time % 3 === 0) {
            speed += 0.6;
            speedDisplay.textContent = speed.toFixed(1);
        }
        
        if(time === 40 && backwardTime > 3) backwardTime = 3;
        if(time === 80 && backwardTime > 2) backwardTime = 2;
        if(time === 60 && forwardTime > 8) forwardTime = 8;
        if(time === 120 && forwardTime > 6) forwardTime = 6;
    },1000);
    
    spawnTimer = setInterval(()=>{
        if(running && direction === 1){
            spawnObstacle();
        }
    },600);
}

loop();
</script>

</body>
</html>
